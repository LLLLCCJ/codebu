# -*- coding: utf-8 -*-
"""NSGA2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12J3yVHsv7M8kUspjqcsLfAgOnJVUJlDp
"""

from copy import deepcopy
import pandas as pd
import networkx as nx
from itertools import combinations,permutations
from random import random,randint

k=4
front=[[1,2,0],[3,4,5]]
front=[[1, 0, 2], [5, 3, 4]]
rank=[0,0,0,1,1,1]
pop_cost=[(110,20),(100,20),(121,10),(132,20),(140,20),(123,20)]

#cost_ASC_sort(front,rank,pop_cost)
#get_margins(3,front,rank,pop_cost)


def _inverse(S,length):
  if S<length:
    return S+length
  else:
    return S-length

def sol_checking(S,genetic_Form):
  gene=list(genetic_Form.keys())
  length=len(gene)//2
  for i in S:
    if i not in gene:
      return "Problem detected"
    else:
      gene.remove(i)
      i_inv=_inverse(i,length)
      gene.remove(i_inv)
  return "Clear!"

def Pythagoras(cor1,cor2):
  a,b,c,d=int(cor1[0]),int(cor1[1]),int(cor2[0]),int(cor2[1])
  result=int(np.sqrt(np.square(a-c)+np.square(b-d)))
  return result

def genetic_Form_gen(G):
  genetic_Form={}
  genetic_Form_reverse={}
  initial_Solution=[]
  for i in range(len(G.edges)):
    genetic_Form[i]=list(G.edges())[i]
    genetic_Form[i+len(G.edges)]=\
     (list(G.edges())[i][1],list(G.edges())[i][0])
    genetic_Form_reverse[list(G.edges())[i]]=i
    genetic_Form_reverse[(list(G.edges())[i][1],list(G.edges())[i][0])]=\
    i+len(G.edges)

  return genetic_Form,genetic_Form_reverse

def path_Cost_map(CG):
  Nodes=CG.nodes()
  shortest_path={}
  shortest_path_cost={}
  for i in Nodes:
    for j in Nodes:
      if i!=j and ((i,j) not in shortest_path and (j,i) not in shortest_path):
          path=nx.dijkstra_path(CG,i,j,'weight')
          cost=nx.path_weight(CG,path,'weight')
          shortest_path[(i,j)]=path
          shortest_path_cost[(i,j)]=cost
  return shortest_path,shortest_path_cost

def load_file(directory):
  df = pd.read_csv(directory, delimiter='\t')

  Q = df.iloc[:, 0].str.split('CAPACIDAD').str[1]
  vehicle = df.iloc[:, 0].str.split('VEHICULOS').str[1]

  num_Of_veh = int(vehicle[4][3:])
  Q = int(Q[5][3:])

  df['Edge'] = df.iloc[:, 0].str.split('coste').str[0]
  df['T'] = df.iloc[:, 0].str.split('coste').str[1]
  df.drop(df.columns[0], axis=1, inplace=True)
  df.dropna(inplace=True)
  df['Cost'] = df.iloc[:, 1].str.split('demanda').str[0]
  df['Demand'] = df.iloc[:, 1].str.split('demanda').str[1]
  df.drop(df.columns[1], axis=1, inplace=True)
  df.reset_index(drop=True, inplace=True)
  df.Edge = df.Edge.str.replace('(', '')
  df.Edge = df.Edge.str.replace(')', '')
  df.Edge = df.Edge.str.replace(' ', '')
  df = df.apply(lambda p: p.str.strip())
  df['From'] = df.iloc[:, 0].str.split(',').str[0]
  df['To'] = df.iloc[:, 0].str.split(',').str[1]
  df.drop(df.columns[0], axis=1, inplace=True)
  demand_Edge = deepcopy(df)
  demand_Edge.dropna(inplace=True)
  demand_Edge = demand_Edge.astype('int32')
  nondemand_Edge = deepcopy(df)
  nondemand_Edge = nondemand_Edge[nondemand_Edge.isna().any(axis=1)]
  nondemand_Edge.drop(df.columns[1], axis=1, inplace=True)
  nondemand_Edge.reset_index(drop=True, inplace=True)
  nondemand_Edge = nondemand_Edge.astype('int32')
  nonD, D = nondemand_Edge, demand_Edge
  G = nx.MultiGraph()
  CG = nx.Graph()
  for i in range(len(D)):
    G.add_edge(D.iloc[i].From, D.iloc[i].To, weight=D.iloc[i].Cost, demand=D.iloc[i].Demand)
    CG.add_edge(D.iloc[i].From, D.iloc[i].To, weight=D.iloc[i].Cost, demand=D.iloc[i].Demand)
  for i in range(len(nonD)):
    CG.add_edge(nonD.iloc[i].From, nonD.iloc[i].To, weight=nonD.iloc[i].Cost, demand=0)

  cost_demand = [[0 for i in range(len(CG.nodes))] for i in range(len(CG.nodes))]
  for i in range(1, len(CG.nodes)):
    for j in range(i + 1, len(CG.nodes) + 1):
      if nx.is_path(CG, (i, j)):
        cost_demand[i - 1][j - 1] = CG[i][j]['weight']
        cost_demand[j - 1][i - 1] = CG[i][j]['demand']
  genetic_Form, genetic_Form_reverse = genetic_Form_gen(G)
  shortest_path, shortest_path_cost = path_Cost_map(CG)

  return genetic_Form, genetic_Form_reverse, cost_demand, G, CG, Q, shortest_path, shortest_path_cost, num_Of_veh


# ns: number of solutions
# pop: solutions

# sort the current solutions (pop)

def dom(S1,S2):
  if S1[0]<S2[0] and S1[1]<S2[1]:
    return True
  else:
    return False

# checked!
def non_dominated_sort(ns,pop_cost):
  # initialize front: from the pareto front there can be a few front.
  front=[[] for i in range(ns)]
  # rank: level of front from pareto front.
  rank=[0 for i in range(ns)]
  # solutions that worse than current solution
  set_worse=[[] for i in range(ns)]
  # number of solutions that is better than current solution
  nb_better=[0 for i in range(ns)]

  # Check the all the solutions' dominance and update the set_worse and nb_better
  for i in range(ns):
    for j in range(ns):
      if dom(pop_cost[i],pop_cost[j]):
        set_worse[i].append(j)
      elif dom(pop_cost[j],pop_cost[i]):
        nb_better[i]+=1
    if nb_better[i]==0:
      front[0].append(i)

  # initialize the number of front
  nf=0

  while True:
    for i in front[nf]:
      rank[i]=nf

      for j in set_worse[i]:
        nb_better[j]-=1
        if nb_better[j]==0:
          front[nf+1].append(j)
    if front[nf+1]==[]:
      break
    nf+=1

  front=cost_ASC_sort(front,pop_cost)

  return front,rank

# checked!
def cost_ASC_sort(front,pop_cost):
  temp=deepcopy(front)
  new_front=[[] for i in range(len(front))]
  # front_cost find first objective fuction value and save to the front_cost for sorting
  for i in range(len(temp)):
    front_cost=[]
    for j in temp[i]:
      # save to the front_cost all the cost of solution of the each front
      front_cost.append(pop_cost[j][0])

    for _ in range(len(front_cost)):
      idx=front_cost.index(min(front_cost))
      target=front[i][idx]
      new_front[i].append(target)
      front_cost[idx]=999999

  return new_front

# not checked!
def add_children(pop,pop_cost,ns,rank,margin,G,Q,cost_demand,genetic_Form,shortest_path_cost,iter,max_cost,min_cost):
  input_ns=ns
  for _ in range(input_ns,2*input_ns):
    P1_idx,P2_idx=crowded_Tournament(ns,rank,margin)
    P1,P2=pop[P1_idx],pop[P2_idx]
    C=OX(P1,P2,genetic_Form)
    C_cost1, C_cost2, _ = split(G, C, Q, cost_demand, genetic_Form, shortest_path_cost)
    C_cost=(C_cost1,C_cost2)
    if iter%10==0:
      C,C_cost=LS(C, C_cost1,C_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost)
    else:
      rand = random()
      if rand < 0.1:
        C,C_cost=mutate(C, G, Q, cost_demand, genetic_Form,shortest_path_cost)
    pop.append(C)
    pop_cost.append(C_cost)
  return pop,pop_cost

# checked!
def max_min(pop_cost):
  cost1=[]
  cost2=[]
  for i in pop_cost:
    cost1.append(i[0])
    cost2.append(i[1])

  max_cost=(max(cost1),max(cost2))
  min_cost=(min(cost1),min(cost2))

  return max_cost,min_cost

def rand_Gen(genetic_Form):
  gene=list(genetic_Form.keys())
  length = len(genetic_Form) // 2
  Sol=[]
  while gene!=[]:
    idx=randint(0,len(gene)-1)
    Sol.append(gene[idx])
    target=gene[idx]
    gene.remove(target)
    if target>=length:
      gene.remove(target-length)
    else:
      gene.remove(target+length)

  return Sol

def rand_Gen(genetic_Form):
  gene=list(genetic_Form.keys())
  length = len(genetic_Form) // 2
  Sol=[]
  while gene!=[]:
    idx=randint(0,len(gene)-1)
    Sol.append(gene[idx])
    target=gene[idx]
    gene.remove(target)
    if target>=length:
      gene.remove(target-length)
    else:
      gene.remove(target+length)

  return Sol
# not checked!
def first_pop(genetic_Form,genetic_Form_reverse,cost_demand,G,CG,Q,num_Of_veh,shortest_path_cost,ns):
  H=[]
  depot=1

  S1,_=EPS(G,CG,Q,num_Of_veh,depot,genetic_Form_reverse,genetic_Form)
  _,_,S2=EAM(G,CG,Q,genetic_Form,genetic_Form_reverse,depot)
  S3,_=EUH(G,Q,cost_demand,genetic_Form_reverse,num_Of_veh,depot,genetic_Form)

  H.append(S1)
  H.append(S2)
  H.append(S3)

  while len(H)<ns:
    S=S1
    while S in H:
      S=rand_Gen(genetic_Form)
    H.append(S)

  H_cost=[]

  for i in H:
    cost1,cost2,_=split(G,i,Q,cost_demand,genetic_Form,shortest_path_cost)
    H_cost.append((cost1,cost2))

  return H,H_cost

def find_Path_cost(shortest_path_cost,i,j):
  if i==j:
    return 0
  if (i,j) not in shortest_path_cost:
    return shortest_path_cost[(j,i)]
  return shortest_path_cost[(i,j)]

def OX(P1,P2,genetic_Form):
  tau=len(P1)
  miss=[True for i in range(2*tau)]
  C=[None for i in range(tau)]
  p=randint(0,tau-2)
  if p==0:
    q=randint(p+1,tau-2)
  else:
    q=randint(p+1,tau-1)

  for i in range(p,q+1):
    C[i]=P1[i]
    miss[P1[i]]=False
    miss[_inverse(P1[i],tau)]=False

  i=(q+1)%tau
  j=(q+1)%tau
  start=i
  while True:
    if miss[P2[i]]:
      C[j]=P2[i]
      miss[P2[i]]=False
      miss[_inverse(P2[i],tau)]=False
      j=(j+1)%tau

    i=(i+1)%tau
    if i==start:
      break
  #print('p',P1)
  #print('p2',P2)
  #print('c',C)
  #print("OX")
  #print(sol_checking(C,genetic_Form))
  return C


# not checked!
def NSGA_2(ns,dir,stopping_criteria):
  print(dir)
  genetic_Form, genetic_Form_reverse, cost_demand, G, CG, Q, shortest_path, shortest_path_cost, num_Of_veh = load_file(
    dir)
  pop,pop_cost=first_pop(genetic_Form,genetic_Form_reverse,cost_demand,G,CG,Q,num_Of_veh,shortest_path_cost,ns) # pop에 해당하는 cost를 저장하고
                             # non dominated sorting 후 cost에 맞게 정렬해야 함.
  max_cost,min_cost=max_min(pop_cost)

  front,rank = non_dominated_sort(ns,pop_cost)
  margin=[0 for i in range(ns*2)]
  for i in range(len(pop)):
    margin[i] = get_margins(i,front,rank,pop_cost)

  iter=0
  while True:
    pop,pop_cost=add_children(pop,pop_cost,ns,rank,margin,G,Q,cost_demand,genetic_Form,shortest_path_cost,iter,max_cost,min_cost)
    front,rank = non_dominated_sort(ns*2,pop_cost)
    for i in range(len(pop)):
      margin[i]=get_margins(i,front,rank,pop_cost)
    newpop=[]
    newpop_cost=[]
    i=0
    while len(newpop)+len(front[i])<=ns:
      for j in front[i]:
        newpop.append(pop[j])
        newpop_cost.append(pop_cost[j])
      i+=1
    missing = ns - len(newpop)
    if missing !=0:
      sorted_Front=margin_Sort(front,i,margin)
      for j in range(missing):
        newpop.append(pop[sorted_Front[j]])
        newpop_cost.append(pop_cost[sorted_Front[j]])

    pop=newpop
    pop_cost=newpop_cost
    max_cost,min_cost=max_min(pop_cost)
    iter+=1
    if iter>stopping_criteria:
      break
  print(pop_cost)
  return pop,pop_cost


# not checked!
def margin_Sort(front,i,margin):
  sorted_Front=[]
  marg=[]

  for j in front[i]:
    marg.append(margin[j])

  for j in range(len(marg)):
    idx=marg.index(max(marg))
    sorted_Front.append(front[i][idx])
    marg[idx]=-9999

  return sorted_Front

# not checked!
def crowded_Tournament(ns,rank,margin):

  # iteration이 끝나지 않음.
  while True:
    i=randint(0,ns-1)
    j=randint(0,ns-1)
    while i==j:
      j=randint(0,ns-1)

    if rank[i]<=rank[j] and margin[i]>margin[j]:
      target1=i
      break
    elif rank[i]>=rank[j] and margin[i]<margin[j]:
      target1=j
      break

  target2=target1
  while target1==target2:
    while True:
      i = randint(0, ns - 1)
      j = randint(0, ns - 1)
      while i == j:
        j = randint(0, ns - 1)

      if rank[i] <= rank[j] and margin[i] > margin[j]:
        target2 = i
        break
      elif rank[i] >= rank[j] and margin[i] < margin[j]:
        target2 = j
        break
  return target1,target2

# checked!
def get_margins(k,front,rank,pop_cost):
  Obj1=[]
  Obj2=[]
  for i in pop_cost:
    Obj1.append(i[0])
    Obj2.append(i[1])
  min_Obj1=min(Obj1)
  max_Obj1=max(Obj1)
  min_Obj2=min(Obj2)
  max_Obj2=max(Obj2)
  k_rank=rank[k]

  idx=front[k_rank].index(k)
  if idx==0 or idx==len(front[k_rank])-1:
    crowd_Dist=999999999
  else:
    crowd_Dist=(pop_cost[front[k_rank][idx+1]][0]-pop_cost[front[k_rank][idx-1]][0])/(max_Obj1-min_Obj1)\
                + (pop_cost[front[k_rank][idx-1]][1]-pop_cost[front[k_rank][idx+1]][1])/(max_Obj2-min_Obj2)
  return crowd_Dist

# checked!
def EPS(G,CG,Q,num_Of_veh,depot,genetic_Form_reverse,genetic_Form):
  length=len(G.edges())

  # Satisfy the criterion, if capacity is exhausted,
  # it would come back to the depot with shortest path.
  # After capacity is satisfied, arc is not "collected" during the back to the depot sequence.

  # (1) maximize the q(v)/w(v) q is the demand w is the servide cost
  # version 1: 논문에서 주어진 정보만을 이용해 구현함.
  def fir_Sol(G,CG,Q,num_Of_veh,depot):
    # subtour will be deleted from A. For preserving original G deepcopy the G to the A
    A=deepcopy(G)
    # All path will be saved
    path=[]
    # All cost will be added
    cost=0
    # real path
    real_path=[]
    for _ in range(num_Of_veh):
      # subtour cost
      subtour_cost=0
      # subtour path
      subtour_path=[]
      # subtour demand
      demand=0
      current=depot

      # real subtour path
      real_subtour_path=[]
      # for the first iteration of under "while" iteration
      while Q>demand:

        # yields mean demand per unit cost. We select the edge to maximize this yield.
        yields=[]
        cand_Edge=[]
        Edge=list(A.edges())
        for i in Edge:
          if i[0]==current:
            cand_Edge.append(i)
          elif i[1]==current:
            cand_Edge.append(i)
        # if there is no option on the demand arc, select among the deadhead edge
        if cand_Edge==[]:

          Edge=list(A.edges())
          n_Cand={}
          cand_Path=[]
          # iteration except depot, prevent back to depot before finish the job
          for i in Edge:
            if current!=depot:
              if depot not in i:
                current=int(current)
                near_1,near_2=nearest_nodes(CG,current,i)
                close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
                close_cost=nx.path_weight(CG,close_path,'weight')
                cand_Path.append(close_path)
                n_Cand[i]=close_cost
          # if there is no option find with depot
          if n_Cand=={}:
            for i in Edge:
              current=int(current)
              near_1,near_2=nearest_nodes(CG,current,i)
              close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
              close_cost=nx.path_weight(CG,close_path,'weight')
              cand_Path.append(close_path)
              n_Cand[i]=close_cost
          if n_Cand=={}:
            break

          min_Dist_idx=list(n_Cand.values()).index(min(list(n_Cand.values())))
          target_Edge=list(n_Cand.keys())[min_Dist_idx]
          target_cost=nx.path_weight(CG,target_Edge,'weight')
          target_demand=nx.path_weight(CG,target_Edge,'demand')
          _,near=nearest_nodes(CG,current,target_Edge)
          # add the deadhead cost
          subtour_cost+=n_Cand[target_Edge]
          # add the target cost
          subtour_cost+=target_cost
          demand+=target_demand
          subtour_path.append(cand_Path[min_Dist_idx])
          subtour_path.append(target_Edge)

          if target_Edge[0]==near:
            current=target_Edge[1]
          else:
            current=target_Edge[0]

          A.remove_edge(target_Edge[0],target_Edge[1])
          continue

        # Find maximum yield among all edge of A
        for i in cand_Edge:
          # calculate the edge i's cost
          i_cost=nx.path_weight(CG,i,'weight')
          # calculate the edge i's demand
          i_demand=nx.path_weight(CG,i,'demand')
          yields.append(i_demand/i_cost)
        # finds the maximum yields edge
        idx=yields.index(max(yields))
        selected_edge=cand_Edge[idx]
        selected_demand=nx.path_weight(CG,selected_edge,'demand')
        selected_cost=nx.path_weight(CG,selected_edge,'weight')
        # only add the collected edge

        demand+=selected_demand
        # if demand is over the capacity, stop the iteration
        # there is no add
        if demand>Q:
          demand-=selected_demand
          break
        # else, add to the subtour cost, path, demand
        else:
          subtour_cost+=selected_cost
          subtour_path.append(selected_edge)
          A.remove_edge(selected_edge[0],selected_edge[1])
          if current==selected_edge[1]:
            current=selected_edge[0]
          elif current==selected_edge[0]:
            current=selected_edge[1]

      deadhead_path=nx.dijkstra_path(CG,current,depot,'weight')
      subtour_path.append(deadhead_path)
      deadhead_cost=nx.path_weight(CG,deadhead_path,'weight')
      subtour_cost+=deadhead_cost
      cost+=subtour_cost
      path.append(subtour_path)
    return path,cost

  # (2) minimize the q(v)/w(v)
  # version 1: 논문에서 주어진 정보만을 이용해 구현함.
  def sec_Sol(G,CG,Q,num_Of_veh,depot):
    # subtour will be deleted from A. For preserving original G deepcopy the G to the A
    A=deepcopy(G)
    # All path will be saved
    path=[]
    # All cost will be added
    cost=0
    # real path
    real_path=[]
    for _ in range(num_Of_veh):
      # subtour cost
      subtour_cost=0
      # subtour path
      subtour_path=[]
      # subtour demand
      demand=0
      current=depot

      # real subtour path
      real_subtour_path=[]
      # for the first iteration of under "while" iteration
      while Q>demand:
        # yields mean demand per unit cost. We select the edge to maximize this yield.
        yields=[]
        cand_Edge=[]
        Edge=list(A.edges())

        for i in Edge:
          if i[0]==current:
            cand_Edge.append(i)
          elif i[1]==current:
            cand_Edge.append(i)
        # if there is no option on the demand arc, select among the deadhead edge
        if cand_Edge==[]:

          Edge=list(A.edges())
          n_Cand={}
          cand_Path=[]
          # iteration except depot, prevent back to depot before finish the job
          for i in Edge:
            if current!=depot:
              if depot not in i:
                current=int(current)
                near_1,near_2=nearest_nodes(CG,current,i)
                close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
                close_cost=nx.path_weight(CG,close_path,'weight')
                cand_Path.append(close_path)
                n_Cand[i]=close_cost
          # if there is no option find with depot
          if n_Cand=={}:
            for i in Edge:
              current=int(current)
              near_1,near_2=nearest_nodes(CG,current,i)
              close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
              close_cost=nx.path_weight(CG,close_path,'weight')
              cand_Path.append(close_path)
              n_Cand[i]=close_cost
          if n_Cand=={}:
            break

          min_Dist_idx=list(n_Cand.values()).index(min(list(n_Cand.values())))
          target_Edge=list(n_Cand.keys())[min_Dist_idx]
          target_cost=nx.path_weight(CG,target_Edge,'weight')
          target_demand=nx.path_weight(CG,target_Edge,'demand')
          _,near=nearest_nodes(CG,current,target_Edge)
          # add the deadhead cost
          subtour_cost+=n_Cand[target_Edge]
          # add the target cost
          subtour_cost+=target_cost
          demand+=target_demand
          subtour_path.append(cand_Path[min_Dist_idx])
          subtour_path.append(target_Edge)

          if target_Edge[0]==near:
            current=target_Edge[1]
          else:
            current=target_Edge[0]

          A.remove_edge(target_Edge[0],target_Edge[1])
          continue

        # Find minimum yield among all edge of A
        for i in cand_Edge:
          # calculate the edge i's cost
          i_cost=nx.path_weight(CG,i,'weight')
          # calculate the edge i's demand
          i_demand=nx.path_weight(CG,i,'demand')
          yields.append(i_demand/i_cost)
        # finds the minimum yields edge
        idx=yields.index(min(yields))
        selected_edge=cand_Edge[idx]
        selected_demand=nx.path_weight(CG,selected_edge,'demand')
        selected_cost=nx.path_weight(CG,selected_edge,'weight')
        # only add the collected edge

        demand+=selected_demand
        # if demand is over the capacity, stop the iteration
        # there is no add
        if demand>Q:
          demand-=selected_demand
          break
        # else, add to the subtour cost, path, demand
        else:
          subtour_cost+=selected_cost
          subtour_path.append(selected_edge)
          A.remove_edge(selected_edge[0],selected_edge[1])
          if current==selected_edge[1]:
            current=selected_edge[0]
          elif current==selected_edge[0]:
            current=selected_edge[1]

      deadhead_path=nx.dijkstra_path(CG,current,depot,'weight')
      subtour_path.append(deadhead_path)
      deadhead_cost=nx.path_weight(CG,deadhead_path,'weight')
      subtour_cost+=deadhead_cost
      cost+=subtour_cost
      path.append(subtour_path)
    return path,cost

  # (3) Maximize the D(v,depot)
  # version 1: 논문에서 주어진 정보만을 이용해 구현함.
  def thir_Sol(G,CG,Q,num_Of_veh,depot):
    # subtour will be deleted from A. For preserving original G deepcopy the G to the A
    A=deepcopy(G)
    # All path will be saved
    path=[]
    # All cost will be added
    cost=0
    # real path
    real_path=[]
    for _ in range(num_Of_veh):
      # subtour cost
      subtour_cost=0
      # subtour path
      subtour_path=[]
      # subtour demand
      demand=0
      current=depot

      # real subtour path
      real_subtour_path=[]
      # for the first iteration of under "while" iteration
      while Q>demand:
        dist=[]
        cand_Edge=[]
        Edge=list(A.edges())
        for i in Edge:
          if i[0]==current:
            cand_Edge.append(i)
          elif i[1]==current:
            cand_Edge.append(i)
        # if there is no option on the demand arc, select among the deadhead edge
        if cand_Edge==[]:

          Edge=list(A.edges())
          n_Cand={}
          cand_Path=[]
          # iteration except depot, prevent back to depot before finish the job
          for i in Edge:
            if current!=depot:
              if depot not in i:
                current=int(current)
                near_1,near_2=nearest_nodes(CG,current,i)
                close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
                close_cost=nx.path_weight(CG,close_path,'weight')
                cand_Path.append(close_path)
                n_Cand[i]=close_cost
          # if there is no option find with depot
          if n_Cand=={}:
            for i in Edge:
              current=int(current)
              near_1,near_2=nearest_nodes(CG,current,i)
              close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
              close_cost=nx.path_weight(CG,close_path,'weight')
              cand_Path.append(close_path)
              n_Cand[i]=close_cost
          if n_Cand=={}:
            break

          min_Dist_idx=list(n_Cand.values()).index(min(list(n_Cand.values())))
          target_Edge=list(n_Cand.keys())[min_Dist_idx]
          target_cost=nx.path_weight(CG,target_Edge,'weight')
          target_demand=nx.path_weight(CG,target_Edge,'demand')
          _,near=nearest_nodes(CG,current,target_Edge)
          # add the deadhead cost
          subtour_cost+=n_Cand[target_Edge]
          # add the target cost
          subtour_cost+=target_cost
          demand+=target_demand
          subtour_path.append(cand_Path[min_Dist_idx])
          subtour_path.append(target_Edge)

          if target_Edge[0]==near:
            current=target_Edge[1]
          else:
            current=target_Edge[0]

          A.remove_edge(target_Edge[0],target_Edge[1])
          continue

        # Find maximum distance from depot among all edge of A
        for i in cand_Edge:
          # calculate the cost from depot to the edge i
          near_1,near_2=nearest_nodes(CG,depot,i)
          i_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
          i_cost=nx.path_weight(CG,i_path,'weight')
          dist.append(i_cost)
        # finds the maximum dist edge
        idx=dist.index(max(dist))
        selected_edge=cand_Edge[idx]
        selected_demand=nx.path_weight(CG,selected_edge,'demand')
        selected_cost=nx.path_weight(CG,selected_edge,'weight')
        # only add the collected edge

        demand+=selected_demand
        # if demand is over the capacity, stop the iteration
        # there is no add
        if demand>Q:
          demand-=selected_demand
          break
        # else, add to the subtour cost, path, demand
        else:
          subtour_cost+=selected_cost
          subtour_path.append(selected_edge)
          A.remove_edge(selected_edge[0],selected_edge[1])
          if current==selected_edge[1]:
            current=selected_edge[0]
          elif current==selected_edge[0]:
            current=selected_edge[1]

      deadhead_path=nx.dijkstra_path(CG,current,depot,'weight')
      subtour_path.append(deadhead_path)
      deadhead_cost=nx.path_weight(CG,deadhead_path,'weight')
      subtour_cost+=deadhead_cost
      cost+=subtour_cost
      path.append(subtour_path)
    return path,cost

  # (4) Minimize the D(v,depot)
  # version 1: 논문에서 주어진 정보만을 이용해 구현함.
  def four_Sol(G,CG,Q,num_Of_veh,depot):
    # subtour will be deleted from A. For preserving original G deepcopy the G to the A
    A=deepcopy(G)
    # All path will be saved
    path=[]
    # All cost will be added
    cost=0
    # real path
    real_path=[]
    for _ in range(num_Of_veh):
      # subtour cost
      subtour_cost=0
      # subtour path
      subtour_path=[]
      # subtour demand
      demand=0
      current=depot

      # for the first iteration of under "while" iteration
      while Q>demand:
        dist=[]
        cand_Edge=[]
        Edge=list(A.edges())

        for i in Edge:
          if i[0]==current:
            cand_Edge.append(i)
          elif i[1]==current:
            cand_Edge.append(i)
        # if there is no option on the demand arc, select among the deadhead edge
        if cand_Edge==[]:

          Edge=list(A.edges())
          n_Cand={}
          cand_Path=[]
          # iteration except depot, prevent back to depot before finish the job
          for i in Edge:
            if current!=depot:
              if depot not in i:
                current=int(current)
                near_1,near_2=nearest_nodes(CG,current,i)
                close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
                close_cost=nx.path_weight(CG,close_path,'weight')
                cand_Path.append(close_path)
                n_Cand[i]=close_cost
          # if there is no option find with depot
          if n_Cand=={}:
            for i in Edge:
              current=int(current)
              near_1,near_2=nearest_nodes(CG,current,i)
              close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
              close_cost=nx.path_weight(CG,close_path,'weight')
              cand_Path.append(close_path)
              n_Cand[i]=close_cost
          if n_Cand=={}:
            break

          min_Dist_idx=list(n_Cand.values()).index(min(list(n_Cand.values())))
          target_Edge=list(n_Cand.keys())[min_Dist_idx]
          target_cost=nx.path_weight(CG,target_Edge,'weight')
          target_demand=nx.path_weight(CG,target_Edge,'demand')
          _,near=nearest_nodes(CG,current,target_Edge)
          # add the deadhead cost
          subtour_cost+=n_Cand[target_Edge]
          # add the target cost
          subtour_cost+=target_cost
          demand+=target_demand
          subtour_path.append(cand_Path[min_Dist_idx])
          subtour_path.append(target_Edge)

          if target_Edge[0]==near:
            current=target_Edge[1]
          else:
            current=target_Edge[0]

          A.remove_edge(target_Edge[0],target_Edge[1])
          continue

        # Find minimum distance from depot among all edge of A
        for i in cand_Edge:
          # calculate the cost from depot to the edge i
          near_1,near_2=nearest_nodes(CG,depot,i)
          i_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
          i_cost=nx.path_weight(CG,i_path,'weight')
          dist.append(i_cost)
        # finds the minimum dist edge
        idx=dist.index(min(dist))
        selected_edge=cand_Edge[idx]
        selected_demand=nx.path_weight(CG,selected_edge,'demand')
        selected_cost=nx.path_weight(CG,selected_edge,'weight')
        # only add the collected edge

        demand+=selected_demand
        # if demand is over the capacity, stop the iteration
        # there is no add
        if demand>Q:
          demand-=selected_demand
          break
        # else, add to the subtour cost, path, demand
        else:
          subtour_cost+=selected_cost
          subtour_path.append(selected_edge)
          A.remove_edge(selected_edge[0],selected_edge[1])
          if current==selected_edge[1]:
            current=selected_edge[0]
          elif current==selected_edge[0]:
            current=selected_edge[1]

      deadhead_path=nx.dijkstra_path(CG,current,depot,'weight')
      subtour_path.append(deadhead_path)
      deadhead_cost=nx.path_weight(CG,deadhead_path,'weight')
      subtour_cost+=deadhead_cost
      cost+=subtour_cost
      path.append(subtour_path)
    return path,cost

  # (5) use rule (3) if the vehicle is less than half-full else use rule(4)
  # version 1: 논문에서 주어진 정보만을 이용해 구현함.
  def fif_Sol(G,CG,Q,num_Of_veh,depot):
        # subtour will be deleted from A. For preserving original G deepcopy the G to the A
    A=deepcopy(G)
    # All path will be saved
    path=[]
    # All cost will be added
    cost=0
    # real path
    real_path=[]
    for _ in range(num_Of_veh):
      # subtour cost
      subtour_cost=0
      # subtour path
      subtour_path=[]
      # subtour demand
      demand=0
      current=depot

      # real subtour path
      real_subtour_path=[]
      # for the first iteration of under "while" iteration

      # if half demand is satisfied stop the maximizing
      while Q//2>demand:
        # yields mean demand per unit cost. We select the edge to maximize this yield.
        dist=[]
        cand_Edge=[]
        Edge=list(A.edges())


        for i in Edge:
          if i[0]==current:
            cand_Edge.append(i)
          elif i[1]==current:
            cand_Edge.append(i)
        # if there is no option on the demand arc, select among the deadhead edge
        if cand_Edge==[]:

          Edge=list(A.edges())
          n_Cand={}
          cand_Path=[]
          # iteration except depot, prevent back to depot before finish the job
          for i in Edge:
            if current!=depot:
              if depot not in i:
                current=int(current)
                near_1,near_2=nearest_nodes(CG,current,i)
                close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
                close_cost=nx.path_weight(CG,close_path,'weight')
                cand_Path.append(close_path)
                n_Cand[i]=close_cost
          # if there is no option find with depot
          if n_Cand=={}:
            for i in Edge:
              current=int(current)
              near_1,near_2=nearest_nodes(CG,current,i)
              close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
              close_cost=nx.path_weight(CG,close_path,'weight')
              cand_Path.append(close_path)
              n_Cand[i]=close_cost
          if n_Cand=={}:
            break

          min_Dist_idx=list(n_Cand.values()).index(min(list(n_Cand.values())))
          target_Edge=list(n_Cand.keys())[min_Dist_idx]
          target_cost=nx.path_weight(CG,target_Edge,'weight')
          target_demand=nx.path_weight(CG,target_Edge,'demand')
          _,near=nearest_nodes(CG,current,target_Edge)
          # add the deadhead cost
          subtour_cost+=n_Cand[target_Edge]
          # add the target cost
          subtour_cost+=target_cost
          demand+=target_demand

          subtour_path.append(cand_Path[min_Dist_idx])
          subtour_path.append(target_Edge)

          if target_Edge[0]==near:
            current=target_Edge[1]
          else:
            current=target_Edge[0]

          A.remove_edge(target_Edge[0],target_Edge[1])
          continue

        # Find maximum distance from depot among all edge of A
        for i in cand_Edge:
          # calculate the cost from depot to the edge i
          near_1,near_2=nearest_nodes(CG,depot,i)
          i_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
          i_cost=nx.path_weight(CG,i_path,'weight')
          dist.append(i_cost)
        # finds the maximum dist edge
        idx=dist.index(max(dist))
        selected_edge=cand_Edge[idx]
        selected_demand=nx.path_weight(CG,selected_edge,'demand')
        selected_cost=nx.path_weight(CG,selected_edge,'weight')
        # only add the collected edge

        demand+=selected_demand
        # if demand is over the capacity, stop the iteration
        # there is no add
        if demand>Q//2:
          demand-=selected_demand
          break
        # else, add to the subtour cost, path, demand
        else:
          subtour_cost+=selected_cost
          subtour_path.append(selected_edge)
          A.remove_edge(selected_edge[0],selected_edge[1])
          if current==selected_edge[1]:
            current=selected_edge[0]
          elif current==selected_edge[0]:
            current=selected_edge[1]

      # start the minimizing
      while Q>demand:
        # yields mean demand per unit cost. We select the edge to maximize this yield.
        dist=[]
        cand_Edge=[]
        Edge=list(A.edges())

        for i in Edge:
          if i[0]==current:
            cand_Edge.append(i)
          elif i[1]==current:
            cand_Edge.append(i)
        # if there is no option on the demand arc, select among the deadhead edge
        if cand_Edge==[]:

          Edge=list(A.edges())
          n_Cand={}
          cand_Path=[]
          # iteration except depot, prevent back to depot before finish the job
          for i in Edge:
            if current!=depot:
              if depot not in i:
                current=int(current)
                near_1,near_2=nearest_nodes(CG,current,i)
                close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
                close_cost=nx.path_weight(CG,close_path,'weight')
                cand_Path.append(close_path)
                n_Cand[i]=close_cost
          # if there is no option find with depot
          if n_Cand=={}:
            for i in Edge:
              current=int(current)
              near_1,near_2=nearest_nodes(CG,current,i)
              close_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
              close_cost=nx.path_weight(CG,close_path,'weight')
              cand_Path.append(close_path)
              n_Cand[i]=close_cost
          if n_Cand=={}:
            break

          min_Dist_idx=list(n_Cand.values()).index(min(list(n_Cand.values())))
          target_Edge=list(n_Cand.keys())[min_Dist_idx]
          target_cost=nx.path_weight(CG,target_Edge,'weight')
          target_demand=nx.path_weight(CG,target_Edge,'demand')
          _,near=nearest_nodes(CG,current,target_Edge)
          # add the deadhead cost
          subtour_cost+=n_Cand[target_Edge]
          # add the target cost
          subtour_cost+=target_cost
          demand+=target_demand

          subtour_path.append(cand_Path[min_Dist_idx])
          subtour_path.append(target_Edge)

          if target_Edge[0]==near:
            current=target_Edge[1]
          else:
            current=target_Edge[0]

          A.remove_edge(target_Edge[0],target_Edge[1])
          continue

        # Find minimum distance from depot among all edge of A
        for i in cand_Edge:
          # calculate the cost from depot to the edge i
          near_1,near_2=nearest_nodes(CG,depot,i)
          i_path=nx.dijkstra_path(CG,near_1,near_2,'weight')
          i_cost=nx.path_weight(CG,i_path,'weight')
          dist.append(i_cost)
        # finds the minimum dist edge
        idx=dist.index(min(dist))
        selected_edge=cand_Edge[idx]
        selected_demand=nx.path_weight(CG,selected_edge,'demand')
        selected_cost=nx.path_weight(CG,selected_edge,'weight')
        # only add the collected edge

        demand+=selected_demand
        # if demand is over the capacity, stop the iteration
        # there is no add
        if demand>Q:
          demand-=selected_demand
          break
        # else, add to the subtour cost, path, demand
        else:
          subtour_cost+=selected_cost
          subtour_path.append(selected_edge)
          A.remove_edge(selected_edge[0],selected_edge[1])
          if current==selected_edge[1]:
            current=selected_edge[0]
          elif current==selected_edge[0]:
            current=selected_edge[1]

      deadhead_path=nx.dijkstra_path(CG,current,depot,'weight')
      subtour_path.append(deadhead_path)
      deadhead_cost=nx.path_weight(CG,deadhead_path,'weight')
      subtour_cost+=deadhead_cost
      cost+=subtour_cost
      path.append(subtour_path)


    return path,cost

  cand_Sol=[]
  Cost=[]
  fir_Sol,fir_cost=fir_Sol(G,CG,Q,num_Of_veh,depot)
  Cost.append(fir_cost)
  cand_Sol.append(fir_Sol)

  sec_Sol,sec_cost=sec_Sol(G,CG,Q,num_Of_veh,depot)
  Cost.append(sec_cost)
  cand_Sol.append(sec_Sol)
  thir_Sol,thir_cost=thir_Sol(G,CG,Q,num_Of_veh,depot)
  Cost.append(thir_cost)
  cand_Sol.append(thir_Sol)
  four_Sol,four_cost=four_Sol(G,CG,Q,num_Of_veh,depot)
  Cost.append(four_cost)
  cand_Sol.append(four_Sol)
  fif_Sol,five_cost=fif_Sol(G,CG,Q,num_Of_veh,depot)
  Cost.append(five_cost)
  cand_Sol.append(fif_Sol)
  main_idx=Cost.index(min(Cost))
  Solution=EPS_convert_to_edges(cand_Sol[main_idx])

  genetic_Sol=[]
  for i in Solution:
    for j in i:

      target=genetic_Form_reverse[j]
      if target<length:
        idx=target+length
      else:
        idx=target-length
      if target not in genetic_Sol and idx not in genetic_Sol:
        genetic_Sol.append(target)
  #print('EPS')
  #print(sol_checking(genetic_Sol,genetic_Form))
  return genetic_Sol,Cost[main_idx]

def nearest_nodes(G,u,v):
  if type(u)==int:
    near_1=u
    near_2=None
    best_cost=999999999999999
    for j in v:
      path=nx.dijkstra_path(G,u,j,'weight')
      cost=nx.path_weight(G,path,'weight')
      if best_cost>cost:
        best_cost=cost
        near_2=j
    return near_1,near_2

  elif type(v)==int:
    near_1=None
    near_2=v
    best_cost=999999999999999
    for i in u:
      path=nx.dijkstra_path(G,i,v,'weight')
      cost=nx.path_weight(G,path,'weight')
      if best_cost>cost:
        best_cost=cost
        near_1=i
    return near_1,near_2

  elif type(u)==tuple and type(v)==tuple:
    near_1=None
    near_2=None
    best_cost=999999999999999
    for i in u:
      for j in v:
        path=nx.dijkstra_path(G,i,j,'weight')
        cost=nx.path_weight(G,path,'weight')
        if best_cost>cost:
          best_cost=cost
          near_1=i
          near_2=j
    return near_1,near_2


# Finds an giant tour
def find_Giant(G,depot):
  g_tour=[depot]
  for i in nx.eulerian_circuit(G,depot):
    g_tour.append(i[1])
  return g_tour

def _oddn(G):
  values=list(dict(G.degree()).values())
  keys=list(dict(G.degree()).keys())
  odd_idx=[]
  odd_nodes=[]
  for i in values:
    if i%2==1:
      idx=values.index(i)
      odd_idx.append(idx)
      values[values.index(i)]=-1
  for j in odd_idx:
    odd_nodes.append(keys[j])
  return odd_nodes

# if G is not an eulerian graph, then make it to the eulerian graph
def CPP(G):

  if nx.is_eulerian(G):
    return G
  else:
    A=deepcopy(G)
    # find odd degree node.
    odd_Degree_node=_oddn(A)
    # find least cost combination among the odd degree nodes.
    odd_Comb=list(combinations(odd_Degree_node,2))
    pairs=list(combinations(odd_Comb,len(odd_Degree_node)//2))

    real_pairs=[]
    for i in pairs:
      overlap=[]
      for j in i:
        if overlap==[]:
          overlap.append(j)
        else:
          flag=True
          for k in overlap:
            if j[0] in k or j[1] in k:
              flag=False
              break
          if flag:
            overlap.append(j)
      if len(overlap)==len(odd_Degree_node)//2:
        real_pairs.append(overlap)
    pairs=real_pairs
    pairs_cost=[]
    for i in pairs:
      cost=0
      for j in i:
        path=nx.dijkstra_path(A,j[0],j[1],'weight')
        cost+=nx.path_weight(A,path,'weight')
      pairs_cost.append(cost)

    pair=pairs[pairs_cost.index(min(pairs_cost))]

    for i in pair:
      path=nx.dijkstra_path(A,i[0],i[1],'weight')
      for i in range(len(path)-1):
        cost=nx.path_weight(A,(path[i],path[i+1]),'weight')
        A.add_edge(path[i],path[i+1],weight=cost)
    return A

def cost_(i,j,cost_demand):
  if i>j:
    i,j=j,i
  return cost_demand[i-1][j-1]

def demand_(i,j,cost_demand):
  if i<j:
    i,j=j,i
  return cost_demand[i-1][j-1]

def no_Service_(euler_Circuit):
  no_service=[]
  euler_Circuit_edge=[]
  for i in range(len(euler_Circuit)-1):
    euler_Circuit_edge.append((euler_Circuit[i],euler_Circuit[i+1]))

  for i in range(len(euler_Circuit_edge)-1):
    for j in range(i+1,len(euler_Circuit_edge)):
      if (euler_Circuit_edge[i]==euler_Circuit_edge[j]) or \
       ((euler_Circuit_edge[i][1],euler_Circuit_edge[i][0])==euler_Circuit_edge[j]):

        no_service.append(euler_Circuit_edge[i])

  return no_service

def EUH(G,Q,cost_demand,genetic_Form_reverse,num_Of_veh,depot,genetic_Form):
  length=len(G.edges())
  G=CPP(G)
  euler_Circuit=find_Giant(G,depot)
  # test euler_Circuit=[1, 5, 6,4,3,4, 5,9,8, 9, 1,8, 10 , 7 , 2 , 3 , 6 , 2 , 10,6, 1]
  # 구한 eulerian circuit에서 deadhead path가 이미 존재하고 찾을 수 있음. 해당 path를 따로 no_service로 저장
  no_service=no_Service_(euler_Circuit)

  G_star_node={}
  G_star_node_rev={}
  # 위에 따라서 G_star cost는 모든 정보를 넣는 dictionary.
  G_star_cost={}
  G_star=nx.MultiGraph()

  G_star_node[1]=1
  G_star_node_rev[1]=1
  G_star_node[2]=euler_Circuit[0],euler_Circuit[1]
  G_star_node_rev[euler_Circuit[0],euler_Circuit[1]]=2

  for i in range(1,len(euler_Circuit)-1):
    G_star_node[i+2]=euler_Circuit[i],euler_Circuit[i+1]
    G_star_node_rev[euler_Circuit[i],euler_Circuit[i+1]]=i+2
  #G_star.add_nodes_from(G_star_node.keys())
  G_star_edge=list(G_star_node.values())


  reall={}
  for i in range(1,len(G_star_edge)-1):
    # 아래 inner loop k 때문에 len()+1을 해야 G_star_edge 마지막 값까지 접근 가능
    for j in range(i+1,len(G_star_edge)+1):
      real_path=[]
      cost=0
      demand=0
      # 첫 edge에 depot이 들어갔는지 확인
      if depot == G_star_edge[i][0]:
        pass
      # 안되어 있으면 DEPOT과 첫 EDGE 연결
      else:

        start_path=nx.dijkstra_path(G,depot,G_star_edge[i][0],'weight')
        start_cost=nx.path_weight(G,start_path,'weight')
        cost+=start_cost
        G_star_cost[depot,G_star_edge[i][0]]=start_cost

      # demand edge (eulerian circuit안의) 를 추가
      for k in range(i,j):
        new_cost=nx.path_weight(G,(G_star_edge[k][0],G_star_edge[k][1]),'weight')
        real_path.append(G_star_edge[k])
        cost+=new_cost
        G_star_cost[G_star_edge[k][0],G_star_edge[k][1]]=new_cost

        demand+=demand_(G_star_edge[k][0],G_star_edge[k][1],cost_demand)

        #Q: vehicle capacity
        # i가 1 j가 5 인데, Q가 3이라면 k가 4 일 땐 연결할 수 없음. 따라서 break

        if demand>Q:
          cost-=new_cost
          del G_star_cost[list(G_star_cost.keys())[-1]]
          k-=1
          break

      # demand가 5 이상 이려면 j와 i의 차가 5 이상 이어야 하는데, 그런 경로는 Capacity Q에 의해 존재할 수 없음.
      if demand>Q:
        break
      reall[i,j]=real_path
      # 경우 1. 위에서 demand가 꽉 차서 k-=1이 된 상태인데 그 전의 edge가 deadhead path일때
      # 경우 2. 위 loop를 다 돌고 나서 deadhead path일 때
      # 경우 3. j와 i의 차가 1일 때, 즉 위 loop가 한 번만 돌았을 때(target demand edge가 deadhead path일 때)
      # 마지막 deadhead path 삭제
      if G_star_edge[k] in no_service and real_path.count(G_star_edge[k])>1:
        del G_star_cost[list(G_star_cost.keys())[-1]]
        cost-=new_cost
        # 경우 3
        ######################
        if j-i==1:
          break

      # 마지막 edge에 depot이 들어갔는지 확인
      if depot == list(G_star_cost.keys())[-1][1]:
        pass
      else:
        end_path=nx.dijkstra_path(G,list(G_star_cost.keys())[-1][1],depot,'weight')
        end_cost=nx.path_weight(G,end_path,'weight')
        cost+=end_cost

      # i에 해당하는 edge는 고려하고 j에 해당하는 edge는 고려하지 않는다. ex. i=1, j=4 면 1,2,3 edge만 고려됨.
      # G_star의 첫번째 노드는 depot이고 두번째부터 edge로써 카운트 됨.
      # G_star에서 edge를 묶을 때, (1,3)으로 묵는다면 node 2와 node 3을 고려함.
      # 따라서 i가 고려되면서 j가 고려되지 않아야 하므로 i-1과 j-1을 edge로 이어야함.

      G_star.add_edge(i,j,weight=cost)
  path=nx.dijkstra_path(G_star,depot,len(G_star_edge),'weight')
  cost=nx.path_weight(G_star,path,'weight')
  solution=[]
  for i in range(len(path)-1):
    solution.append(euler_Circuit[path[i]:path[i+1]])
  real_path=[]
  for i in range(len(path)-1):
    #if i==0:
    real_path.append(reall[path[i],path[i+1]])
    #else:
      #real_path.append(reall[path[i]+1,path[i+1]])



  genetic_Sol=[]
  for i in real_path:
    for j in i:
      target=genetic_Form_reverse[j]
      if target<length:
        idx=target+length
      else:
        idx=target-length
      if target not in genetic_Sol and idx not in genetic_Sol:
        genetic_Sol.append(target)
  #print('EUH')
  #print(sol_checking(genetic_Sol,genetic_Form))
  return genetic_Sol,cost

# Finds an giant tour
def find_Giant(G,depot):
  g_tour=[depot]
  for i in nx.eulerian_circuit(G,depot):
    g_tour.append(i[1])
  return g_tour

def _oddn(G):
  values=list(dict(G.degree()).values())
  keys=list(dict(G.degree()).keys())
  odd_idx=[]
  odd_nodes=[]
  for i in values:
    if i%2==1:
      idx=values.index(i)
      odd_idx.append(idx)
      values[values.index(i)]=-1
  for j in odd_idx:
    odd_nodes.append(keys[j])
  return odd_nodes

# if G is not an eulerian graph, then make it to the eulerian graph
# depot과 이어야 함.
def CPP(G):
  if nx.is_eulerian(G):
    return G
  else:
    A=deepcopy(G)
    # find odd degree node.
    odd_Degree_node=_oddn(A)

    # find least cost combination among the odd degree nodes.
    odd_Comb=list(combinations(odd_Degree_node,2))
    pairs=list(combinations(odd_Comb,len(odd_Degree_node)//2))

    real_pairs=[]
    for i in pairs:
      overlap=[]
      for j in i:
        if overlap==[]:
          overlap.append(j)
        else:
          flag=True
          for k in overlap:
            if j[0] in k or j[1] in k:
              flag=False
              break
          if flag:
            overlap.append(j)
      if len(overlap)==len(odd_Degree_node)//2:
        real_pairs.append(overlap)
    pairs=real_pairs
    pairs_cost=[]
    for i in pairs:
      cost=0
      for j in i:
        path=nx.dijkstra_path(A,j[0],j[1],'weight')
        cost+=nx.path_weight(A,path,'weight')
      pairs_cost.append(cost)

    pair=pairs[pairs_cost.index(min(pairs_cost))]

    for i in pair:
      path=nx.dijkstra_path(A,i[0],i[1],'weight')
      for i in range(len(path)-1):
        cost=nx.path_weight(A,(path[i],path[i+1]),'weight')
        A.add_edge(path[i],path[i+1],weight=cost)
    return A
def EPS_convert_to_edges(data):
  edges = []
  for group in data:
    subedges=[]
    for item in group:
      # 리스트를 연속된 edge로 변환
      for i in range(len(item)-1):
        subedges.append((item[i],item[i+1]))
    edges.append(subedges)
  return edges

def EAM_convert_to_edges(data):
  edges = []

  for group in data:
    subedges=[]
    for item in group:
      # 리스트를 연속된 edge로 변환
      for i in item:
        subedges.append(i)
    edges.append(subedges)
  return edges

def initial_Sol_gen(G,CG,depot):
  demand_Edges=list(G.edges())

  initial_Trip=[[] for i in range(len(demand_Edges))]
  initial_Trip_cost=[]
  init_Trip_dict={}
  Demand=[]

  target_Demand=[[] for i in range(len(demand_Edges))]

  for i in range(len(demand_Edges)):
    cost=0
    near1,near2=nearest_nodes(G,depot,demand_Edges[i])
    path=nx.dijkstra_path(CG,near1,near2,'weight')
    cost+=nx.path_weight(CG,path,'weight')
    dem=nx.path_weight(G,demand_Edges[i],'demand')
    Demand.append(dem)
    initial_Trip[i].append(path)

    target_Demand[i].append(demand_Edges[i])

    if near2==demand_Edges[i][0]:
      near1=demand_Edges[i][1]
    else:
      near1=demand_Edges[i][0]

    near2=depot
    path=nx.dijkstra_path(CG,near1,near2,'weight')
    cost+=nx.path_weight(CG,path,'weight')
    initial_Trip[i].append(path)
    cost+=nx.path_weight(CG,demand_Edges[i],'weight')
    initial_Trip_cost.append(cost)
  initial_Trip=EAM_convert_to_edges(initial_Trip)



  for i in range(len(initial_Trip)):
    init_Trip_dict[tuple(initial_Trip[i])]=initial_Trip_cost[i]


  real_Sol=[]
  Sol=[]
  Sol_cost=[]


  while initial_Trip_cost!=[]:
    idx=initial_Trip_cost.index(max(initial_Trip_cost))
    real_Sol.append(tuple(initial_Trip[idx]))
    Sol_cost.append(initial_Trip_cost[idx])
    Sol.append(target_Demand[idx][0])

    del target_Demand[idx]
    del initial_Trip_cost[idx]
    del initial_Trip[idx]

  return real_Sol,Sol,Sol_cost,Demand

def Augment(G,CG,Q,depot,Sol,Demand):
  for i in range(len(Sol)-1):
    for j in range(i+1,len(Sol)):
      if Demand[i]+Demand[j]<=Q:
        Demand[i]+=Demand[j]

        Sol[i]+=Sol[j]
        Demand[j]+=Q
        Sol[j]=[]

  return Sol,Demand

def connect(CG,A,current_edge,Edges,connect_edges={},saved=None,current_node=-1,flag=True):
  current_node=int(current_node)


  if len(Edges)==1:
    if current_node==-1:
      path=current_edge
    else:
      path=nx.dijkstra_path(CG,saved,current_node,'weight')


    for j in range(len(path)-1):
      cost=nx.path_weight(CG,(path[j],path[j+1]),'weight')
      connect_edges[(path[j],path[j+1])]=cost
      A.add_edge(path[j],path[j+1],weight=cost)

    return A

  Temp=deepcopy(connect_edges)

  connect_dict={}

  # Edges 돌면서 current edge와 가장 가까운 edge 찾아 연결하기.
  for i in Edges:
    if current_edge==i:
      continue
    if current_node==-1:
      near_1,near_2=nearest_nodes(CG,current_edge,i)
    else:
      near_1,near_2=nearest_nodes(CG,current_node,i)

    # 정상적으로 돌아간 이후 바로 위 if문으로 삽입하기. (current node가 -1인 경우가 가장 처음이므로)
    if flag:
      if current_edge[0]==near_1:
        saved=current_edge[1]
        current_node=int(current_edge[0])
      else:
        saved=current_edge[0]
        current_node=int(current_edge[1])
      flag=False


    # near 1과 near 2가 같은 경우는 이미 연결되어 있어 연결할 필요 없음.
    if near_1==near_2:
      Edges.remove(current_edge)

      # flag를 설정해서 eulerian circuit을 만들기 위해 가장 처음 연결되는 edge의 시작 node를 저장하고 추후 마지막 edge와 연결함.
      current_edge=i
      if i[0]==near_2:
        current_node=i[1]
      else:
        current_node=i[0]


      return connect(CG,A,current_edge,Edges,connect_edges,saved,current_node,flag)

    # 같지 않은 경우 모든 경우의 수를 찾아야 하므로 cost를 계산해 dictionary에 저장
    else:
      path=nx.dijkstra_path(CG,near_1,near_2,'weight')
      cost=nx.path_weight(CG,path,'weight')
      connect_dict[i]=cost

  # 전체 dictionary 중에 minimum cost 찾기

  connect_path=list(connect_dict.keys())
  connect_cost=list(connect_dict.values())
  idx=connect_cost.index(min(connect_cost))

  # minimum cost edge를 찾아서 target edge로 설정
  target_edge=connect_path[idx]

  # target edge와 current edge 연결
  near_1,near_2=nearest_nodes(CG,current_node,target_edge)
  path=nx.dijkstra_path(CG,near_1,near_2,'weight')


  if target_edge[0]==near_2:
    current_node=target_edge[1]
  else:
    current_node=target_edge[0]

  for j in range(len(path)-1):
    cost=nx.path_weight(CG,(path[j],path[j+1]),'weight')
    connect_edges[(path[j],path[j+1])]=cost
    A.add_edge(path[j],path[j+1],weight=cost)



  Edges.remove(current_edge)
  current_edge=connect_path[idx]



  return connect(CG,A,current_edge,Edges,connect_edges,saved,current_node,flag)

def Merge(A,G,CG,Sol,depot,all_Edges):

  T=deepcopy(A)
  connect_dict={}
  Edges=deepcopy(list(A.edges()))

  current_edge=Edges[0]
  # A를 하나로 연결
  A=connect(CG,A,current_edge,Edges,connect_edges={})

  if depot in A.nodes():
    return sum(nx.get_edge_attributes(A,'weight').values())

  # delete할 edge랑 add할 edge 찾기
  _delete=[]
  _add=[]
  final_cost=[]

  # 전체 edge 돌면서 depot과의 거리가 가장 가까운 edge 찾기
  for i in A.edges():
    fin_cost=0
    near_1,near_2=nearest_nodes(CG,depot,i)
    path=nx.dijkstra_path(CG,near_1,near_2,'weight')
    add_cost=nx.path_weight(CG,path,'weight')

    fin_cost+=add_cost

    # depot과 가장 가까운 node near_2와 연결된 edge 중 가장 cost가 높은 edge 찾기.
    delete=[]
    delete_cost=[]
    add=[]
    add_cost_=[]
    define=[]
    for j in A.edges():
      if i==j:
        continue
      # demand edge를 삭제해서는 안됨.
      # 초기에 저장된 Edges(demand edges)에 삭제할 edge가 포함되었는지 확인.

      if near_2 == j[0] and j not in all_Edges:
          del_cost=nx.path_weight(CG,j,'weight')
          delete.append(j)
          delete_cost.append(del_cost)

          path=nx.dijkstra_path(CG,j[1],depot,'weight')
          ed=[]
          for i in range(len(path)-1):
            ed.append((path[i],path[i+1]))

          path=ed
          add_cost=0
          for ed in path:
            add_cost+=nx.path_weight(CG,ed,'weight')

          add.append(tuple(path))
          add_cost_.append(add_cost)

          define.append(-del_cost+add_cost)

      elif near_2 == j[1] and j not in all_Edges:
          del_cost=nx.path_weight(CG,j,'weight')
          delete.append(j)
          delete_cost.append(del_cost)

          path=nx.dijkstra_path(CG,j[0],depot,'weight')

          ed=[]
          for i in range(len(path)-1):
            ed.append((path[i],path[i+1]))

          path=ed
          add_cost=0
          for ed in path:
            add_cost+=nx.path_weight(CG,ed,'weight')

          add.append(tuple(path))
          add_cost_.append(add_cost)

          define.append(-del_cost+add_cost)

    # 모두 demand edge와 연결된 경우
    if delete==[]:
      continue

    else:
      # 이런 부분 minimum dictionary or maximum dictionary 찾는 함수 따로 생성하기
      delete_edges=delete
      add_edges=add
      idx=define.index(min(define))

      fin_cost+=define[idx]

    _delete.append((delete_edges[idx]))

    _add.append((near_1,near_2,(add_edges[idx])))

    final_cost.append(fin_cost)

  idx=final_cost.index(min(final_cost))

  A.remove_edge(_delete[idx][0],_delete[idx][1])

  path=nx.dijkstra_path(CG,_add[idx][0],_add[idx][1],'weight')



  for i in range(len(path)-1):
    cost=nx.path_weight(CG,(path[i],path[i+1]),'weight')
    A.add_edge(path[i],path[i+1],weight=cost)

  for i in _add[idx][2]:
    cost=nx.path_weight(CG,(i[0],i[1]),'weight')
    A.add_edge(i[0],i[1],weight=cost)

  return sum(nx.get_edge_attributes(A,'weight').values())

def EAM(G,CG,Q,genetic_Form,genetic_Form_reverse,depot):
  real_Sol,Sol,Sol_cost,Demand=initial_Sol_gen(G,CG,depot)

  Sol_edge=[]
  for i in Sol:
    Edges=[]
    for j in range(len(i)-1):
      Edges.append((i[j],i[j+1]))
    Sol_edge.append(Edges)
  Sol=Sol_edge
  while True:
    prev_Sol = deepcopy(Sol)
    Sol,Demand=Augment(G,CG,Q,depot,Sol,Demand)

    if Sol==prev_Sol:
      break

  # Edge form으로 변경
  temp=[]

  for i in Sol:

    temp2=[]
    if i==[]:
      continue
    if len(i)>1:
      for j in range(len(i)-1):
        temp2.append(i[j])
      temp2.append(i[j+1])

    else:
      temp2=i
    temp.append(temp2)

  Sol=temp

  real_Sol=[]

  all_Edges=[]
  for i in Sol:
    for j in i:
      all_Edges.append(j)

  _cost=0

  for i in Sol:
    A=nx.MultiGraph()
    for j in i:
      cost=nx.path_weight(CG,j,'weight')
      A.add_edge(j[0],j[1],weight=cost)

    _cost+=Merge(A,G,CG,Sol,depot,i)

  gene=[]

  for i in Sol:
    for j in i:
      gene.append(genetic_Form_reverse[j])
  #print('EAM')
  #print(sol_checking(gene,genetic_Form))
  return Sol,_cost,gene


# max_cost, min_cost 따로 저장하기.
# checked!
def LS_accept(S_cost1,S_cost2,temp_cost1,temp_cost2,max_cost,min_cost):
  w=((S_cost1-min_cost[0])/(max_cost[0]-min_cost[0]))/(((S_cost1-min_cost[0])/(max_cost[0]-min_cost[0]))+((S_cost2-min_cost[1])/(max_cost[1]-min_cost[1])))
  
  result=w*(temp_cost1-S_cost1)+(1-w)*(temp_cost2-S_cost2)

  '''
  if temp_cost1<S_cost1:
    return True
  else:
    return False
  '''

  if result<-1:
    return True
  else:
    return False

# not Checked!
def LS(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost):
  def N1(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost,flag=True):
    before=[]
    while flag:
      flag = False
      for i in range(len(S)):
        temp = deepcopy(S)
        temp[i] = _inverse(temp[i], len(temp))
        temp_cost1, temp_cost2, _ = split(G, temp, Q, cost_demand, genetic_Form, shortest_path_cost)
        if LS_accept(S_cost1,S_cost2,temp_cost1,temp_cost2,max_cost,min_cost) and temp not in before:
          before.append(temp)
          S_cost1,S_cost2 = temp_cost1,temp_cost2
          S = temp

          flag = True
    #print('N1')
    #print(S)
    #print(sol_checking(S,genetic_Form))
    return S, (S_cost1,S_cost2)

  def N2(S, S_cost1, S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost,flag=True):
    length_List = [i for i in range(len(S))]
    before = []
    while flag:
      flag = False
      for i, j in permutations(length_List, 2):
        temp = deepcopy(S)
        if j == 0:
          value = temp[i]
          temp[i] = -1
          temp.insert(0, value)
          temp.remove(-1)
        else:
          value = temp[i]
          temp[i] = -1
          temp.insert(j + 1, value)
          temp.remove(-1)
        temp_cost1, temp_cost2, _ = split(G, temp, Q, cost_demand, genetic_Form, shortest_path_cost)
        if LS_accept(S_cost1, S_cost2, temp_cost1, temp_cost2, max_cost, min_cost) and temp not in before:
          before.append(temp)
          S_cost1,S_cost2 = temp_cost1,temp_cost2
          S = temp
          flag = True

    #print('N2')
    #print(S)
    #print(sol_checking(S,genetic_Form))
    return S,  (S_cost1,S_cost2)

  def N3(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost,flag=True):
    length_List = [i for i in range(len(S))]
    before=[]
    while flag:
      flag = False
      for i, j in permutations(length_List, 2):
        if i < len(S) - 1:
          temp = deepcopy(S)
          if j == 0:
            value1, value2 = temp[i], temp[i + 1]
            temp[i], temp[i + 1] = -1, -1
            temp.insert(j, value2)
            temp.insert(j, value1)
            temp.remove(-1)
            temp.remove(-1)
          else:
            value1, value2 = temp[i], temp[i + 1]
            temp[i], temp[i + 1] = -1, -1
            temp.insert(j + 1, value2)
            temp.insert(j + 1, value1)
            temp.remove(-1)
            temp.remove(-1)
          temp_cost1, temp_cost2, _ = split(G, temp, Q, cost_demand, genetic_Form, shortest_path_cost)
          if LS_accept(S_cost1, S_cost2, temp_cost1, temp_cost2, max_cost, min_cost) and temp not in before:
            before.append(temp)
            S_cost1,S_cost2 = temp_cost1,temp_cost2
            S = temp
            flag = True
    #print('N3')
    #print(S)
    #print(sol_checking(S,genetic_Form))
    return S, (S_cost1,S_cost2)

  def N5(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost,flag=True):
    length_List = [i for i in range(len(S))]
    before=[]
    while flag:
      flag = False
      for i, j in combinations(length_List, 2):
        temp = deepcopy(S)
        target = deepcopy(temp[i:j + 1])
        target = target[::-1]
        for k in range(len(target)):
          target[k] = _inverse(k, len(temp))
        temp = temp[:i] + target + temp[j + 1:]
        temp_cost1, temp_cost2, _ = split(G, temp, Q, cost_demand, genetic_Form, shortest_path_cost)
        if LS_accept(S_cost1, S_cost2, temp_cost1, temp_cost2, max_cost, min_cost) and temp not in before:
          before.append(temp)
          S_cost1,S_cost2 = temp_cost1,temp_cost2
          S = temp
          flag = True
    #print('N5')
    #print(S)
    #print(sol_checking(S,genetic_Form))
    return S, (S_cost1,S_cost2)

  S, S_cost = N1(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost)
  S, S_cost = N2(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost)
  S, S_cost = N3(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost)
  #S, S_cost = N4(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost)
  #S, S_cost = N5(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost,max_cost,min_cost)
  return S, S_cost

def mutate(S, G, Q, cost_demand, genetic_Form,shortest_path_cost):
  length_List = [i for i in range(len(S))]
  for i, j in combinations(length_List, 2):
    temp = deepcopy(S)
    temp[i], temp[j] = temp[j], temp[i]
    temp_cost1, temp_cost2, _ = split(G, temp, Q, cost_demand, genetic_Form, shortest_path_cost)


    S_cost1,S_cost2 = temp_cost1,temp_cost2
    S = temp
    #print('mutate')
    #print(S)
    #print(sol_checking(S,genetic_Form))
    return S,  (S_cost1,S_cost2)

# checked!
def split(G,S,Q,cost_demand,genetic_Form,shortest_path_cost):
  Obj1=[1000000 for i in range(len(S)+1)]
  tour_IDX=[]
  # test
  Arc=[0 for i in range(len(S)+1)]
  Obj1[0]=0
  for i in range(1,len(S)+1):
    demand,cost=0,0
    j=i
    while (j<=len(S)) and (demand<Q):
      if i==j:
        Sol=genetic_Form[S[j-1]]
        demand+=demand_(Sol[0],Sol[1],cost_demand)
        cost+=find_Path_cost(shortest_path_cost,1,Sol[0])
        cost+=cost_(Sol[0],Sol[1],cost_demand)
        cost+=find_Path_cost(shortest_path_cost,Sol[1],1)
      else:
        Sol,_Sol=genetic_Form[S[j-1]],genetic_Form[S[j-2]]
        demand+=demand_(Sol[0],Sol[1],cost_demand)
        cost-=find_Path_cost(shortest_path_cost,_Sol[1],1)
        cost+=find_Path_cost(shortest_path_cost,_Sol[1],Sol[0])
        cost+=cost_(Sol[0],Sol[1],cost_demand)
        cost+=find_Path_cost(shortest_path_cost,Sol[1],1)
      if demand<=Q:
        New=cost+Obj1[i-1]
        if New<Obj1[j] or ((New==Obj1[j]) and (Arc[i-1]+1<Arc[j])):
          tour_IDX.append((i,j))
          Obj1[j]=New
          Arc[j]=Arc[i-1]+1
        j+=1

  target=tour_IDX[-1]
  tour=[target]
  tour_IDX_reverse=tour_IDX[::-1]
  for i in range(len(tour_IDX_reverse)):
    if tour_IDX_reverse[i][1]==target[0]-1:
      idx=-i
      tour.append(tour_IDX_reverse[i])
      target=tour_IDX_reverse[i]

  tour=tour[::-1]

  Obj2=Obj1[tour[0][1]]
  for i in range(len(tour)-1):
    target=Obj1[tour[i+1][1]]-Obj1[tour[i][1]]
    if target>Obj2:
      Obj2=target

  Obj1=Obj1[-1]

  return Obj1,Obj2,tour

if __name__=='__main__':
  NSGA_2(ns=30,dir="gdb2.dat",stopping_criteria=200)