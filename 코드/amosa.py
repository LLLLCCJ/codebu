# -*- coding: utf-8 -*-
"""AMOSA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11BN21gCR4NJFoVqEBgXY2Q5iU4nb0xPy
"""

# HL = 100 SL = 200 gamma 2 clustering iteration 300

import numpy as np
from sklearn.cluster import KMeans
import pandas as pd
from random import randint,random
from copy import deepcopy
import networkx as nx
from itertools import permutations
from warnings import filterwarnings

filterwarnings('ignore')
# algorithm begin with hill climbing technique, accepting new solution only if dominates the previous one.
# similar with local search method.

def _inverse(S,length):
  if S<length:
    return S+length
  else:
    return S-length

def cost_(i,j,cost_demand):
  if i>j:
    i,j=j,i
  return cost_demand[i-1][j-1]

def demand_(i,j,cost_demand):
  if i<j:
    i,j=j,i
  return cost_demand[i-1][j-1]

def Pythagoras(cor1,cor2):
  a,b,c,d=int(cor1[0]),int(cor1[1]),int(cor2[0]),int(cor2[1])
  result=int(np.sqrt(np.square(a-c)+np.square(b-d)))
  return result

def genetic_Form_gen(G):
  genetic_Form={}
  genetic_Form_reverse={}
  initial_Solution=[]
  for i in range(len(G.edges)):
    genetic_Form[i]=list(G.edges())[i]
    genetic_Form[i+len(G.edges)]=\
     (list(G.edges())[i][1],list(G.edges())[i][0])
    genetic_Form_reverse[list(G.edges())[i]]=i
    genetic_Form_reverse[(list(G.edges())[i][1],list(G.edges())[i][0])]=\
    i+len(G.edges)

  return genetic_Form,genetic_Form_reverse

def path_Cost_map(CG):
  Nodes=CG.nodes()
  shortest_path={}
  shortest_path_cost={}
  for i in Nodes:
    for j in Nodes:
      if i!=j and ((i,j) not in shortest_path and (j,i) not in shortest_path):
          path=nx.dijkstra_path(CG,i,j,'weight')
          cost=nx.path_weight(CG,path,'weight')
          shortest_path[(i,j)]=path
          shortest_path_cost[(i,j)]=cost
  return shortest_path,shortest_path_cost

def load_file(directory):
  df = pd.read_csv(directory, delimiter='\t')

  Q = df.iloc[:, 0].str.split('CAPACIDAD').str[1]
  vehicle = df.iloc[:, 0].str.split('VEHICULOS').str[1]

  num_Of_veh = int(vehicle[4][3:])
  Q = int(Q[5][3:])

  df['Edge'] = df.iloc[:, 0].str.split('coste').str[0]
  df['T'] = df.iloc[:, 0].str.split('coste').str[1]
  df.drop(df.columns[0], axis=1, inplace=True)
  df.dropna(inplace=True)
  df['Cost'] = df.iloc[:, 1].str.split('demanda').str[0]
  df['Demand'] = df.iloc[:, 1].str.split('demanda').str[1]
  df.drop(df.columns[1], axis=1, inplace=True)
  df.reset_index(drop=True, inplace=True)
  df.Edge = df.Edge.str.replace('(', '')
  df.Edge = df.Edge.str.replace(')', '')
  df.Edge = df.Edge.str.replace(' ', '')
  df = df.apply(lambda p: p.str.strip())
  df['From'] = df.iloc[:, 0].str.split(',').str[0]
  df['To'] = df.iloc[:, 0].str.split(',').str[1]
  df.drop(df.columns[0], axis=1, inplace=True)
  demand_Edge = deepcopy(df)
  demand_Edge.dropna(inplace=True)
  demand_Edge = demand_Edge.astype('int32')
  nondemand_Edge = deepcopy(df)
  nondemand_Edge = nondemand_Edge[nondemand_Edge.isna().any(axis=1)]
  nondemand_Edge.drop(df.columns[1], axis=1, inplace=True)
  nondemand_Edge.reset_index(drop=True, inplace=True)
  nondemand_Edge = nondemand_Edge.astype('int32')
  nonD, D = nondemand_Edge, demand_Edge
  G = nx.MultiGraph()
  CG = nx.Graph()
  for i in range(len(D)):
    G.add_edge(D.iloc[i].From, D.iloc[i].To, weight=D.iloc[i].Cost, demand=D.iloc[i].Demand)
    CG.add_edge(D.iloc[i].From, D.iloc[i].To, weight=D.iloc[i].Cost, demand=D.iloc[i].Demand)
  for i in range(len(nonD)):
    CG.add_edge(nonD.iloc[i].From, nonD.iloc[i].To, weight=nonD.iloc[i].Cost, demand=0)

  cost_demand = [[0 for i in range(len(CG.nodes))] for i in range(len(CG.nodes))]
  for i in range(1, len(CG.nodes)):
    for j in range(i + 1, len(CG.nodes) + 1):
      if nx.is_path(CG, (i, j)):
        cost_demand[i - 1][j - 1] = CG[i][j]['weight']
        cost_demand[j - 1][i - 1] = CG[i][j]['demand']
  genetic_Form, genetic_Form_reverse = genetic_Form_gen(G)
  shortest_path, shortest_path_cost = path_Cost_map(CG)

  return genetic_Form, genetic_Form_reverse, cost_demand, G, CG, Q, shortest_path, shortest_path_cost, num_Of_veh

def find_Path_cost(shortest_path_cost,i,j):
  if i==j:
    return 0
  if (i,j) not in shortest_path_cost:
    return shortest_path_cost[(j,i)]
  return shortest_path_cost[(i,j)]

def rand_Gen(genetic_Form):
  gene=list(genetic_Form.keys())
  length = len(genetic_Form) // 2
  Sol=[]
  while gene!=[]:
    idx=randint(0,len(gene)-1)
    Sol.append(gene[idx])
    target=gene[idx]
    gene.remove(target)
    if target>=length:
      gene.remove(target-length)
    else:
      gene.remove(target+length)
  return Sol

def initial_S(SL,G,Q,cost_demand,genetic_Form,shortest_path_cost,gamma):
  Archive,Archive_cost=[],[]
  for i in range(int(SL*gamma)):
    S = rand_Gen(genetic_Form)
    cost1,cost2,_ = split(G,S,Q,cost_demand,genetic_Form,shortest_path_cost)
    S_cost = (cost1,cost2)
    Archive.append(S)
    Archive_cost.append(S_cost)
  return Archive,Archive_cost

def dom(S1,S2):
  # 0: S1이 더 좋음
  if S1[0]<=S2[0] and S1[1]<=S2[1]:
    return 0
  # 2: S2가 더 좋음
  elif (S1[0]>S2[0] and S1[1]>=S2[1]) or (S1[0]>=S2[0] and S1[1]>S2[1]):
    return 2
  # non dominated relationship
  else:
    return 1

def non_dom_sort(Archive,Archive_cost):

  for target in range(len(Archive_cost)):
    mtc=Archive_cost[target]
    for i in range(len(Archive_cost)):
      if dom(Archive_cost[i],mtc)==2:
        Archive_cost[i] = (999999999, 999999999)
        Archive[i]=[-1]
  while (999999999,999999999) in Archive_cost:
    Archive_cost.remove((999999999,999999999))
    Archive.remove([-1])
  return Archive,Archive_cost

def AMOSA(directory,Tmax=1000,Tmin=0,HL=100,SL=200,iter=1000,alpha=0.9,gamma=2,clustering_iter=300):
  temp=Tmax
  genetic_Form, genetic_Form_reverse, cost_demand, G, CG, Q, shortest_path, shortest_path_cost, num_Of_veh=load_file(directory)
  Archive,Archive_cost=initial_S(SL,G,Q,cost_demand,genetic_Form,shortest_path_cost,gamma)
  Archive,Archive_cost=non_dom_sort(Archive,Archive_cost)
  if len(Archive)>SL:
    Archive, Archive_cost = clustering(Archive_cost, Archive, HL, clustering_iter)
  print(len(Archive_cost),len(Archive))
  if len(Archive)>1:
    idx=randint(0,len(Archive)-1)
  else:
    idx=0
  current_pt=deepcopy(Archive[idx])
  current_pt_cost=deepcopy(Archive_cost[idx])
  print(Archive_cost)
  print(current_pt_cost)
  while temp>Tmin:
    for _ in range(iter):
      new_pt,new_pt_cost=mutate(current_pt, current_pt_cost[0],current_pt_cost[1], G, Q, cost_demand, genetic_Form,shortest_path_cost)
      # current dominate the new
      # Case 1
      dominate_check=dom(current_pt_cost,new_pt_cost)
      if dominate_check==0:
        dom_avg=0
        k=0
        for i in Archive_cost:
          if dom(i,new_pt_cost)==0:
            k+=1
            dom_avg+=dominance(i,new_pt_cost,Archive_cost)
        dom_avg+=dominance(current_pt_cost,new_pt_cost,Archive_cost)
        dom_avg/=(k+1)
        prob=1/(1+np.exp(dom_avg * temp))
        RAN=random()
        if prob>RAN:
          #print('a')
          current_pt=new_pt
          current_pt_cost=new_pt_cost

      # non dominate relationship
      # Case 2
      elif dominate_check==1:
        dominate_list=[]
        dominated_list=[]
        non_dominate_list=[]
        for i in range(len(Archive_cost)):
          sec_dominate_check=dom(Archive_cost[i],new_pt_cost)
          if sec_dominate_check==0:
            dominate_list.append(i)
          elif sec_dominate_check == 1:
            non_dominate_list.append(i)
          elif sec_dominate_check==2:
            dominated_list.append(i)

          else:
            print('Case 2 is something wrong')

        # Case 2 - 1
        if dominate_list!=[]:
          dom_avg=0
          for i in dominate_list:
            dom_avg+=dominance(Archive_cost[i],new_pt_cost,Archive_cost)
          dom_avg/=(len(dominate_list))
          prob=1/(1+np.exp(dom_avg * temp))
          RAN=random()
          if prob>RAN:
            #print('b')
            current_pt=new_pt
            current_pt_cost=new_pt_cost

        # Case 2 - 2
        elif len(non_dominate_list)==len(Archive):
          #print(9)
          current_pt=new_pt
          current_pt_cost=new_pt_cost
          Archive.append(current_pt)
          Archive_cost.append(current_pt_cost)

          if len(Archive)>SL:

            Archive,Archive_cost=clustering(Archive_cost,Archive,HL,clustering_iter)

        # Case 2 - 3
        elif dominated_list!=[]:
          #print(8)
          current_pt=new_pt
          current_pt_cost=new_pt_cost
          Archive.append(current_pt)
          Archive_cost.append(current_pt_cost)

          # should be confirmed
          dominated_list=sorted(dominated_list,reverse=True)

          for i in dominated_list:
            del Archive[i]
            del Archive_cost[i]

        else:
          print('Case 22 is something wrong')

      # Case 3
      elif dominate_check==2:
        dominate_list=[]
        dominated_list=[]
        non_dominate_list = []
        for i in range(len(Archive_cost)):
          third_dominate_check=dom(Archive_cost[i],new_pt_cost)
          if third_dominate_check==0:

            dominate_list.append(i)
          elif third_dominate_check==1:

            non_dominate_list.append(i)
          elif third_dominate_check==2:

            dominated_list.append(i)
          else:
            print('Case 3 is something wrong')

        # Case 3 - 1
        if dominate_list!=[]:
          dom_min=99999999
          for i in dominate_list:

            target_dom=dominance(Archive_cost[i],new_pt_cost,Archive_cost)

            if target_dom<dom_min:
              dom_min=target_dom
              target=Archive[i]
              target_cost=Archive_cost[i]
          prob=1/(1+np.exp(-dom_min))
          RAN=random()
          if prob>RAN:
            #print('c')
            current_pt=target
            current_pt_cost=target_cost
          else:
            #print('d')
            current_pt=new_pt
            current_pt_cost=new_pt_cost

        # Case 3 - 2
        elif len(non_dominate_list)==len(Archive):
          idx=None
          for i in range(len(Archive)):
            if current_pt==Archive[i]:
              idx=i
              break

          if idx is not None:
            del Archive[idx]
            del Archive_cost[idx]
          #print(5)
          current_pt=new_pt
          current_pt_cost=new_pt_cost
          Archive.append(current_pt)
          Archive_cost.append(current_pt_cost)


          if len(Archive)>SL:

            Archive,Archive_cost=clustering(Archive_cost,Archive,HL,clustering_iter)


        # Case 3 - 3
        elif dominated_list!=[]:
          #print(4)
          current_pt=new_pt
          current_pt_cost=new_pt_cost
          Archive.append(current_pt)
          Archive_cost.append(current_pt_cost)

          # should be confirmed
          dominated_list=sorted(dominated_list,reverse=True)

          for i in dominated_list:
            del Archive[i]
            del Archive_cost[i]


        else:
          print('Case 33 is something wrong')

      else:
        print('dominate_check is something wrong')
    print(Archive_cost)
    temp*=alpha
  if len(Archive)>SL:

    Archive,Archive_cost=clustering(Archive_cost,Archive,HL,clustering_iter)

  return Archive,Archive_cost

def euc_D(Cost):
  return np.sqrt((Cost[0]**2)+(Cost[1]**2))

# single linkage clustering: cluster 간 데이터 거리 중 최소 값을 이용.=> kmeans clustering으로 변경
# 각 데이터 간의 거리를 재서 table로 만들어야 함
# 200개 이상의 archive를 HL 만큼으로 줄여야 함

# kmeans clustering

def clustering(Archive_cost,Archive,HL,clustering_iter):
  kmeans = KMeans(n_clusters=HL, n_init=clustering_iter)
  Temp_AC=np.ones((1,2))
  for i in Archive_cost:
    Temp_AC=np.concatenate((Temp_AC,np.array(i).reshape(1,2)))

  Temp_AC=Temp_AC[1:]
  kmeans.fit(Temp_AC)

  # 각 데이터 포인트가 속한 클러스터 번호 출력
  labels = kmeans.labels_
  # 각 클러스터에 속한 데이터 출력
  #clusters = {i: Archive_cost[labels == i] for i in range(HL)}
  cluster_centers = kmeans.cluster_centers_
  target_idx=[]
  for i in cluster_centers:
    d=[np.linalg.norm(np.array(i)-np.array(j)) for j in Archive_cost]
    idx=np.nanargmin(d)
    #print(d,idx)
    while idx in target_idx:
      d[idx]=[999999999999,999999999999]
      idx=np.nanargmin(d)
    target_idx.append(idx)

  Archive=[Archive[idx] for idx in target_idx]
  Archive_cost=[Archive_cost[idx] for idx in target_idx]

  return Archive,Archive_cost

def dominance(exist,new,Archive_cost):
  R1=np.max(Archive_cost,axis=0)
  R2=np.min(Archive_cost,axis=0)
  R=R2-R1
  result=(abs(exist[0]-new[0])/R[0])*(abs(exist[1]-new[1])/R[1])
  return result

# 방향을 바꾸는 것을 고려해서 삽입하기
def mutate(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost):
  # N1 reverse
  def N1(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost):
    i=randint(0,len(S)-1)

    temp = deepcopy(S)

    temp[i] = _inverse(temp[i], len(temp))

    temp_cost1, temp_cost2, _ = split(G, temp, Q, cost_demand, genetic_Form, shortest_path_cost)
    S=temp
    S_cost1,S_cost2=temp_cost1,temp_cost2
    return S, (S_cost1,S_cost2)

  # N2 insert
  def N2(S, S_cost1, S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost):
    # length_List = [i for i in range(len(S))]
    i=randint(0,len(S)-1)
    j=randint(0,len(S)-1)
    while i==j:
      j = randint(0, len(S) - 1)

    temp = deepcopy(S)
    if j == 0:
      value = temp[i]
      temp[i] = -1
      temp.insert(0, value)
      temp.remove(-1)
    else:
      value = temp[i]
      temp[i] = -1
      temp.insert(j + 1, value)
      temp.remove(-1)
    temp_cost1, temp_cost2, _ = split(G, temp, Q, cost_demand, genetic_Form, shortest_path_cost)

    S_cost1,S_cost2 = temp_cost1,temp_cost2
    S = temp
    return S,  (S_cost1,S_cost2)

  # N3 edge insert
  def N3(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost):
    i=randint(0,len(S)-2)
    j=randint(0,len(S)-1)

    while i==j:
      j = randint(0, len(S) - 1)

    temp = deepcopy(S)
    if j == 0:
      value1, value2 = temp[i], temp[i + 1]
      temp[i], temp[i + 1] = -1, -1
      temp.insert(j, value2)
      temp.insert(j, value1)
      temp.remove(-1)
      temp.remove(-1)
    else:
      value1, value2 = temp[i], temp[i + 1]
      temp[i], temp[i + 1] = -1, -1
      temp.insert(j + 1, value2)
      temp.insert(j + 1, value1)
      temp.remove(-1)
      temp.remove(-1)

    temp_cost1, temp_cost2, _ = split(G, temp, Q, cost_demand, genetic_Form, shortest_path_cost)

    S_cost1,S_cost2 = temp_cost1,temp_cost2
    S = temp
    return S, (S_cost1,S_cost2)

  random_number=randint(0,2)

  #print(S_cost1, S_cost2)
  if random_number==0:
    S,S_cost=N1(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost)
  elif random_number==1:
    S,S_cost=N2(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost)
  elif random_number==2:
    S,S_cost=N3(S, S_cost1,S_cost2, G, Q, cost_demand, genetic_Form,shortest_path_cost)
  else:
    print('Error')
  #print(S_cost)
  return S,S_cost

def split(G,S,Q,cost_demand,genetic_Form,shortest_path_cost):
  Obj1=[1000000 for i in range(len(S)+1)]
  tour_IDX=[]
  # test
  Arc=[0 for i in range(len(S)+1)]
  Obj1[0]=0
  for i in range(1,len(S)+1):
    demand,cost=0,0
    j=i
    while (j<=len(S)) and (demand<Q):
      if i==j:
        Sol=genetic_Form[S[j-1]]
        demand+=demand_(Sol[0],Sol[1],cost_demand)
        cost+=find_Path_cost(shortest_path_cost,1,Sol[0])
        cost+=cost_(Sol[0],Sol[1],cost_demand)
        cost+=find_Path_cost(shortest_path_cost,Sol[1],1)
      else:
        Sol,_Sol=genetic_Form[S[j-1]],genetic_Form[S[j-2]]
        demand+=demand_(Sol[0],Sol[1],cost_demand)
        cost-=find_Path_cost(shortest_path_cost,_Sol[1],1)
        cost+=find_Path_cost(shortest_path_cost,_Sol[1],Sol[0])
        cost+=cost_(Sol[0],Sol[1],cost_demand)
        cost+=find_Path_cost(shortest_path_cost,Sol[1],1)
      if demand<=Q:
        New=cost+Obj1[i-1]
        if New<Obj1[j] or ((New==Obj1[j]) and (Arc[i-1]+1<Arc[j])):
          tour_IDX.append((i,j))
          Obj1[j]=New
          Arc[j]=Arc[i-1]+1
        j+=1

  target=tour_IDX[-1]
  tour=[target]
  tour_IDX_reverse=tour_IDX[::-1]
  for i in range(len(tour_IDX_reverse)):
    if tour_IDX_reverse[i][1]==target[0]-1:
      idx=-i
      tour.append(tour_IDX_reverse[i])
      target=tour_IDX_reverse[i]
  tour=tour[::-1]
  Obj2=Obj1[tour[0][1]]
  for i in range(len(tour)-1):
    target=Obj1[tour[i+1][1]]-Obj1[tour[i][1]]
    if target>Obj2:
      Obj2=target
  Obj1=Obj1[-1]
  return Obj1,Obj2,tour


if __name__=='__main__':
  AMOSA(directory="./gdb4.dat")